# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: EndDeviceProtocol.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List

import betterproto


class ExpressionInstructions(betterproto.Enum):
    CONST = 0
    VAR = 1
    AND = 2
    OR = 3
    NOT = 4
    LT = 5
    GT = 6
    EQ = 7
    ADD = 8
    SUB = 9
    MUL = 10
    DIV = 11
    MOD = 12


class WindowAggregationType(betterproto.Enum):
    MIN = 0
    MAX = 1
    SUM = 2
    AVG = 3
    COUNT = 4


class WindowSizeType(betterproto.Enum):
    TIMEBASED = 0
    COUNTBASED = 1


@dataclass
class Value(betterproto.Message):
    _uint8_32: int = betterproto.uint32_field(1, group="value")
    _uint64: int = betterproto.uint64_field(2, group="value")
    _int8_32: int = betterproto.sint32_field(3, group="value")
    _int64: int = betterproto.sint64_field(4, group="value")
    _float: float = betterproto.float_field(5, group="value")
    _double: float = betterproto.double_field(6, group="value")


@dataclass
class Data(betterproto.Message):
    instruction: "ExpressionInstructions" = betterproto.enum_field(1, group="data")
    value: "Value" = betterproto.message_field(2, group="data")


@dataclass
class Output(betterproto.Message):
    responses: List["OutputQueryResponse"] = betterproto.message_field(1)


@dataclass
class OutputQueryResponse(betterproto.Message):
    id: int = betterproto.int32_field(1)
    response: List["Value"] = betterproto.message_field(2)


@dataclass
class Expression(betterproto.Message):
    instructions: List["Data"] = betterproto.message_field(1)


@dataclass
class MapOperation(betterproto.Message):
    function: List["Data"] = betterproto.message_field(1)
    attribute: int = betterproto.int32_field(2)


@dataclass
class FilterOperation(betterproto.Message):
    predicate: List["Data"] = betterproto.message_field(1)


@dataclass
class WindowOperation(betterproto.Message):
    size: int = betterproto.int32_field(1)
    size_type: "WindowSizeType" = betterproto.enum_field(2)
    aggregation_type: "WindowAggregationType" = betterproto.enum_field(3)
    start_attribute: int = betterproto.int32_field(4)
    end_attribute: int = betterproto.int32_field(5)
    result_attribute: int = betterproto.int32_field(6)
    read_attribute: int = betterproto.int32_field(7)


@dataclass
class Query(betterproto.Message):
    # bytes resultType = 1; //For some reason minipb breaks if I make this a
    # repeated enum or int32
    operations: List["QueryOperation"] = betterproto.message_field(1)


@dataclass
class QueryOperation(betterproto.Message):
    map: "MapOperation" = betterproto.message_field(1)
    filter: "FilterOperation" = betterproto.message_field(2)
    window: "WindowOperation" = betterproto.message_field(3)


@dataclass
class Message(betterproto.Message):
    queries: List["Query"] = betterproto.message_field(1)
